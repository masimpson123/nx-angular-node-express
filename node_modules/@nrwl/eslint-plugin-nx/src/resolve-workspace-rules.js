"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.workspaceRules = void 0;
const fs_1 = require("fs");
const path_1 = require("path");
const constants_1 = require("./constants");
const read_default_tsconfig_1 = require("@swc-node/register/read-default-tsconfig");
const register_1 = require("@swc-node/register/register");
/**
 * Optionally, if ts-node and tsconfig-paths are available in the current workspace, apply the require
 * register hooks so that .ts files can be used for writing workspace lint rules.
 *
 * If ts-node and tsconfig-paths are not available, the user can still provide an index.js file in
 * tools/eslint-rules and write their rules in JavaScript and the fundamentals will still work (but
 * workspace path mapping will not, for example).
 */
function registerTSWorkspaceLint() {
    try {
        (0, register_1.register)((0, read_default_tsconfig_1.readDefaultTsConfig)((0, path_1.join)(constants_1.WORKSPACE_PLUGIN_DIR, 'tsconfig.json')));
        const tsconfigPaths = require('tsconfig-paths');
        // Load the tsconfig from tools/eslint-rules/tsconfig.json
        const tsConfigResult = tsconfigPaths.loadConfig(constants_1.WORKSPACE_PLUGIN_DIR);
        /**
         * Register the custom workspace path mappings with node so that workspace libraries
         * can be imported and used within custom workspace lint rules.
         */
        return tsconfigPaths.register({
            baseUrl: tsConfigResult.absoluteBaseUrl,
            paths: tsConfigResult.paths,
        });
    }
    catch (err) { }
}
exports.workspaceRules = (() => {
    // If `tools/eslint-rules` folder doesn't exist, there is no point trying to register and load it
    if (!(0, fs_1.existsSync)(constants_1.WORKSPACE_PLUGIN_DIR)) {
        return {};
    }
    // Register `tools/eslint-rules` for TS transpilation
    const registrationCleanup = registerTSWorkspaceLint();
    try {
        /**
         * Currently we only support applying the rules from the user's workspace plugin object
         * (i.e. not other things that plugings can expose like configs, processors etc)
         */
        const { rules } = require(constants_1.WORKSPACE_PLUGIN_DIR);
        // Apply the namespace to the resolved rules
        const namespacedRules = {};
        for (const [ruleName, ruleConfig] of Object.entries(rules)) {
            namespacedRules[`${constants_1.WORKSPACE_RULE_NAMESPACE}/${ruleName}`] = ruleConfig;
        }
        return namespacedRules;
    }
    catch (err) {
        return {};
    }
    finally {
        if (registrationCleanup) {
            registrationCleanup();
        }
    }
})();
//# sourceMappingURL=resolve-workspace-rules.js.map